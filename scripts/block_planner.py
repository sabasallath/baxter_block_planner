#!/usr/bin/env python
# coding: utf-8

# Copyright (c) 2013-2015, Rethink Robotics
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the Rethink Robotics nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
# Author : F. Fleury
# Version : 1.0
# Date : 28/04/2017
# Subject : manage some blocksworld problems with Baxter

"""
Baxter RSDK Inverse Kinematics Pick and Place Demo
"""

import struct
import sys
import os
import copy
import rospy
import rospkg
import baxter_interface
import json
from gazebo_msgs.srv import (
    SpawnModel,
    DeleteModel,
)
from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion,
)
from std_msgs.msg import (
    Header,
    Empty,
    String,
)
from baxter_core_msgs.srv import (
    SolvePositionIK,
    SolvePositionIKRequest,
)
from planification_baxter.srv import *

# Because probleme 16 needs 9 blocks
MAX_BLOCKS = 4
MAX_PROBLEM = 1

class Solver():
    def selection(self, problemId):
        scriptPath = os.path.dirname(os.path.realpath(__file__)) + "/"
        #	Call core_java to analyse and solve the problem
        #	Results are written in JSON format in the JSONPlan.json file
        #	This file is parsed with python and the actions and the parameters are displayed

        problemName = "p" + str(problemId).zfill(2)

        pathProblem = scriptPath + "pddl4j/pddl/blocksworld/" + str(problemName) + ".pddl"
        pathDomain = scriptPath + "pddl4j/pddl/blocksworld/domain.pddl"

        print(pathProblem)

        javaCommand = "java -jar " + scriptPath + "core-pddl4j.jar -o " + pathDomain + " -f " + pathProblem

        print("--> launched command : " + javaCommand)
        # Launch the java command generated by the choices of the problem directory and the problem number
        os.chdir(scriptPath)
        os.system(javaCommand)

        print("Resolution plan : " + str(problemName))

        with open(scriptPath + 'jsonFiles/JSONPlan.json') as data_file:
            data = json.load(data_file)

        actionList = list()
        for actionNumber in xrange(0, len(data) - 5):
            actionType = data['Action ' + str(actionNumber)]['Names']
            nbParameters = len(data["Action " + str(actionNumber)]['Parameters'])
            parameter = data["Action " + str(actionNumber)]['Parameters'][nbParameters-1]
            actionList.append((actionType, parameter))
        return actionList

# BlocksWorld Class
class BlocksWorld():
    def __init__(self, nbBlocks, x_base=0.6725, y_base=0.0565, z_base=1.4):
        self._x_base = x_base
        self._y_base = y_base
        self._z_base = z_base
        self._x_dec = 0.02
        self._y_dec = 0.02
        self._z_dec = -0.155
        self._nbBlocks = nbBlocks
        self._color = ["blue", "red", "green", "yellow", "black", "purple", "white", "grey"]
        self._blockSlotPosition = list()
        for i in range(MAX_BLOCKS):
            self._blockSlotPosition.append(Pose(
                position=Point(self._x_base + 0.1 * (i // 4), self._y_base + 0.1 * (i % 4),
                               self._z_base), orientation=Quaternion(0, 0, 0, 1)))
        self._blockSlot = list()
        # An orientation for gripper fingers to be overhead and parallel to the obj
        """self._overhead_orientation = Quaternion(
                                 x=-0.0249590815779,
                                 y=0.999649402929,
                                 z=0.00737916180073,
                                 w=0.00486450832011)
        """
        self._slotPositionList = 0

    def gen_blocks(self):
        self.load_gazebo_models_nb(self._nbBlocks, self._color)
        for i in range(self._nbBlocks):
            self._blockSlot.append([i])

    def del_blocks(self):
        self.delete_gazebo_models_nb(self._nbBlocks, self._color)
        self._nbBlocks = 0
        self._blockSlot = list()

    def getPoseSlot(self, slot):
        return self._blockSlotPosition[slot]

    def getNbSlot(self, slot):
        return len(self._blockSlot[slot])

    def updatePickSlot(self, slot):
        return self._blockSlot[slot].pop()

    def updatePlaceSlot(self, slot, element):
        self._blockSlot[slot].append(element)

    def search(self, element):
        for i in range(len(self._blockSlot)):
            if (len(self._blockSlot[i]) != 0):
                if self._blockSlot[i][-1] == element:
                    return i
        return -1

    def load_gazebo_models_nb(self, nbBlock, color):
        table_pose = Pose(position=Point(x=1.0, y=0.0, z=0.0))
        table_reference_frame = block_reference_frame = "world"
        # Get Models' Path
        model_path = rospkg.RosPack().get_path('baxter_block_planner') + "/models/"
        # Load Table SDF
        table_xml = ''
        with open(model_path + "cafe_table/model.sdf", "r") as table_file:
            table_xml = table_file.read().replace('\n', '')

        block_xml_list = list()
        # Load Block URDF

        for i in range(nbBlock):
            block_xml = ''
            with open(model_path + "block/model_" + color[i % len(color)] + ".urdf", "r") as block_file:
                block_xml = block_file.read().replace('\n', '')
                block_xml_list.append(block_xml)

        # Spawn Table SDF
        rospy.wait_for_service('/gazebo/spawn_sdf_model')
        try:
            spawn_sdf = rospy.ServiceProxy('/gazebo/spawn_sdf_model', SpawnModel)
            resp_sdf = spawn_sdf("cafe_table", table_xml, "/",
                                 table_pose, table_reference_frame)
        except rospy.ServiceException as e:
            rospy.logerr("Spawn SDF service call failed: {0}".format(e))
        # Spawn Block URDF
        rospy.wait_for_service('/gazebo/spawn_urdf_model')
        try:
            # spawn_urdf = rospy.ServiceProxy('/gazebo/spawn_urdf_model', SpawnModel)
            # resp_urdf = spawn_urdf("block", block_xml, "/",
            # block_pose, block_reference_frame)
            spawn_urdf = rospy.ServiceProxy('/gazebo/spawn_urdf_model', SpawnModel)

            for i in range(nbBlock):
                resp_urdf = spawn_urdf("block_" + color[i % len(color)] + "_" + str((i // len(color))),
                                       block_xml_list[i], "/",
                                       self._blockSlotPosition[i], block_reference_frame)
        except rospy.ServiceException as e:
            rospy.logerr("Spawn URDF service call failed: {0}".format(e))

    def delete_gazebo_models_nb(self, nbBlock, color):
        # This will be called on ROS Exit, deleting Gazebo models
        # Do not wait for the Gazebo Delete Model service, since
        # Gazebo should already be running. If the service is not
        # available since Gazebo has been killed, it is fine to error out
        try:
            delete_model = rospy.ServiceProxy('/gazebo/delete_model', DeleteModel)
            for i in range(nbBlock):
                resp_delete = delete_model("block_" + color[i % len(color)] + "_" + str((i // len(color))))
            resp_delete = delete_model("cafe_table")
            block_pose_list = list()
        except rospy.ServiceException as e:
            rospy.loginfo("Delete Model service call failed: {0}".format(e))


# Robot Class
class Robot(object):
    def __init__(self, limb, hover_distance=0.15, verbose=True):
        print("\n\n\n\nInitialisation de la classe Robot")
        self._limb_name = limb  # string
        self._hover_distance = hover_distance  # in meters
        self._verbose = verbose  # bool
        self._limb = baxter_interface.Limb(limb)
        self._gripper = baxter_interface.Gripper(limb)
        ns = "ExternalTools/" + limb + "/PositionKinematicsNode/IKService"
        self._iksvc = rospy.ServiceProxy(ns, SolvePositionIK)
        rospy.wait_for_service(ns, 5.0)
        # verify robot is enabled
        print("Getting robot state... ")
        self._rs = baxter_interface.RobotEnable(baxter_interface.CHECK_VERSION)
        self._init_state = self._rs.state().enabled
        print("Enabling robot... ")
        self._rs.enable()

    # Function for moving to start position
    def move_to_start(self):
        # Starting Joint angles for left arm
        start_angles = {'left_w0': 0.6699952259595108,
                                 'left_w1': 1.030009435085784,
                                 'left_w2': -0.4999997247485215,
                                 'left_e0': -1.189968899785275,
                                 'left_e1': 1.9400238130755056,
                                 'left_s0': -0.08000397926829805,
                                 'left_s1': -0.9999781166910306}
        print("Moving the {0} arm to start pose...".format(self._limb_name))
        if not start_angles:
            start_angles = dict(zip(self._joint_names, [0] * 7))
        self._guarded_move_to_joint_position(start_angles)
        self.gripper_open()
        rospy.sleep(1.0)
        print("Running. Ctrl-c to quit")

    def ik_request(self, pose):
        hdr = Header(stamp=rospy.Time.now(), frame_id='base')
        ikreq = SolvePositionIKRequest()
        ikreq.pose_stamp.append(PoseStamped(header=hdr, pose=pose))
        try:
            resp = self._iksvc(ikreq)
        except (rospy.ServiceException, rospy.ROSException) as e:
            rospy.logerr("Service call failed: %s" % (e,))
            return False
        # Check if result valid, and type of seed ultimately used to get solution
        # convert rospy's string representation of uint8[]'s to int's
        resp_seeds = struct.unpack('<%dB' % len(resp.result_type), resp.result_type)
        limb_joints = {}
        if resp_seeds[0] != resp.RESULT_INVALID:
            seed_str = {
                ikreq.SEED_USER: 'User Provided Seed',
                ikreq.SEED_CURRENT: 'Current Joint Angles',
                ikreq.SEED_NS_MAP: 'Nullspace Setpoints',
            }.get(resp_seeds[0], 'None')
            if self._verbose:
                print("IK Solution SUCCESS - Valid Joint Solution Found from Seed Type: {0}".format(
                    (seed_str)))
            # Format solution into Limb API-compatible dictionary
            limb_joints = dict(zip(resp.joints[0].name, resp.joints[0].position))
            if self._verbose:
                print("IK Joint Solution:\n{0}".format(limb_joints))
                print("------------------")
        else:
            rospy.logerr("INVALID POSE - No Valid Joint Solution Found.")
            return False
        return limb_joints

    def _guarded_move_to_joint_position(self, joint_angles):
        if joint_angles:
            self._limb.move_to_joint_positions(joint_angles)
        else:
            rospy.logerr("No Joint Angles provided for move_to_joint_positions. Staying put.")

    def gripper_open(self):
        self._gripper.open()
        rospy.sleep(1)

    def gripper_close(self):
        self._gripper.close()
        rospy.sleep(1)

    def _approach(self, pose):
        approach = copy.deepcopy(pose)
        # approach with a pose the hover-distance above the requested pose
        approach.position.z = approach.position.z + self._hover_distance
        joint_angles = self.ik_request(approach)
        self._guarded_move_to_joint_position(joint_angles)

    def _retract(self):
        # retrieve current pose from endpoint
        current_pose = self._limb.endpoint_pose()
        ik_pose = Pose()
        ik_pose.position.x = current_pose['position'].x
        ik_pose.position.y = current_pose['position'].y
        ik_pose.position.z = current_pose['position'].z + self._hover_distance
        ik_pose.orientation.x = current_pose['orientation'].x
        ik_pose.orientation.y = current_pose['orientation'].y
        ik_pose.orientation.z = current_pose['orientation'].z
        ik_pose.orientation.w = current_pose['orientation'].w
        joint_angles = self.ik_request(ik_pose)
        # servo up from current pose
        self._guarded_move_to_joint_position(joint_angles)

    def _servo_to_pose(self, pose):
        # servo down to release
        joint_angles = self.ik_request(pose)
        self._guarded_move_to_joint_position(joint_angles)

    def pick(self, pose):
        print(pose)
        # open the gripper
        self.gripper_open()
        # servo above pose
        self._approach(pose)
        # servo to pose
        self._servo_to_pose(pose)
        # close gripper
        self.gripper_close()
        # retract to clear object
        self._retract()

    def place(self, pose):
        # servo above pose
        self._approach(pose)
        # servo to pose
        self._servo_to_pose(pose)
        # open the gripper
        self.gripper_open()
        # retract to clear object
        self._retract()


def main():
    """RSDK Inverse Kinematics Pick and Place Example

    A Pick and Place example using the Rethink Inverse Kinematics
    Service which returns the joint angles a requested Cartesian Pose.
    This ROS Service client is used to request both pick and place
    poses in the /base frame of the robot.

    Note: This is a highly scripted and tuned demo. The object location
    is "known" and movement is done completely open loop. It is expected
    behavior that Baxter will eventually mis-pick or drop the block. You
    can improve on this demo by adding perception and feedback to close
    the loop.
    """
    rospy.init_node("manage_blocks")
    rospy.wait_for_message("/robot/sim/started", Empty)
    robot = Robot('left', hover_distance=0.15)
    blocksWorld = BlocksWorld(nbBlocks=0)
    solver = Solver()
    robot.move_to_start()

    while True:
        print("-----------------------------------------")
        print("(s1) Solve pddl problem number 1")
        print("(s) Solve pddl problem number n")
        print("(g) Generate n blocks")
        print("(d) Delete all previously imported object")
        print("(i) Pick slot n")
        print("(a) Place to slot n")
        print("(q) Quit")
        com = raw_input("> ")
        if(com == "q"):
            break
        elif (com == "s1"):
            if (blocksWorld._nbBlocks != 4):
                blocksWorld.del_blocks()
                blocksWorld = BlocksWorld(4)
                blocksWorld.gen_blocks()
            solve(blocksWorld, 1, robot, solver)
        elif (com == "s"):
            problemId = guard_input(MAX_PROBLEM, "problemId")
            solve(blocksWorld, problemId, robot, solver)
        elif (com == "g"):
            n = guard_input(MAX_BLOCKS)
            robot.move_to_start()
            if (n < blocksWorld._nbBlocks):
                blocksWorld.del_blocks()
            blocksWorld = BlocksWorld(n)
            blocksWorld.gen_blocks()
        elif (com == "d"):
            blocksWorld.del_blocks()
        elif (com == "i"):
            slot = guard_input(MAX_BLOCKS, "slot")
            pickSlot(blocksWorld, robot, slot)
        elif (com == "a"):
            slot = guard_input(MAX_BLOCKS, "slot")
            placeSlot(blocksWorld, robot, slot)
        else:
            raw_input("Invalid Choice")

    blocksWorld.del_blocks()
    return 0


def solve(blocksWorld, problemId, robot, solver):
    actionList = solver.selection(problemId)
    carriedElement = False
    for action in actionList:
        actionType, param = action
        element = ord(param) - 97
        if (actionType == 'pick-up'):
            slot = blocksWorld.search(element)
            if slot == -1:
                print(param + "not found in pick action")
            else:
                carriedElement = element
                pickSlot(blocksWorld, robot, slot)
                blocksWorld.updatePickSlot(slot)
        elif (actionType == 'stack'):
            slot = blocksWorld.search(element)
            if slot == -1:
                print(param + "not found in place action")
            else:
                placeSlot(blocksWorld, robot, slot)
                if carriedElement != False:
                    blocksWorld.updatePlaceSlot(slot, carriedElement)
                    carriedElement = False
                else:
                    print("/!\ Incoherent world")


def guard_input(max, strN="n"):
    n = int(raw_input("> " + strN +" = "))
    if (n < 0):
        print("Invalid negative imput, "+ strN +" set to " + str(0))
        n = 0
    if (n > max):
        print("Too much, "+ strN + " set to " + str(max))
        n = max
    return n

def placeSlot(blocksWorld, robot, slot):
    print("PLACE SLOT : " + str(slot))
    pose = blocksWorld.getPoseSlot(slot)
    x_dec = blocksWorld._x_dec
    y_dec = blocksWorld._y_dec
    z_dec = blocksWorld._z_dec + (blocksWorld.getNbSlot(slot)) * 0.04 + 0.04
    robot.place(Pose(position=Point(pose.position.x + x_dec, pose.position.y + y_dec, z_dec),
                     orientation=Quaternion(0, 1, 0, 0)))



def pickSlot(blocksWorld, robot, slot):
    print("PICK SLOT : " + str(slot))
    pose = blocksWorld.getPoseSlot(slot)
    x_dec = blocksWorld._x_dec
    y_dec = blocksWorld._y_dec
    z_dec = blocksWorld._z_dec + (blocksWorld.getNbSlot(slot) - 1) * 0.04
    robot.pick(Pose(position=Point(pose.position.x + x_dec, pose.position.y + y_dec, z_dec),
                    orientation=Quaternion(0, 1, 0, 0)))


if __name__ == '__main__':
    sys.exit(main())
